#!/usr/bin/env python

"""
PLOT MESH OBJECTS
plots that derive from the Delaunay mesh objects generated by codes/mesh.py
"""

#---block: what to plot
routine = ['curvature'][-1:]
mass_table = {'H':1.008,'C':12.011,'O':15.999,'N':14.007,'P':30.974,'S':32.065}

def plot(curvs_map,q1o,q2o,mvecs,identifier):
	from mpl_toolkits.axes_grid1.inset_locator import inset_axes

	curvs_map = np.transpose(curvs_map)
	vmax = max([abs(j) for j in [curvs_map.max(),curvs_map.min()]])
	print(vmax)
	ax = plt.gca()
	im = ax.imshow(curvs_map,cmap=mpl.cm.RdBu,vmax=vmax,vmin=-1*vmax,origin='lower',
		extent=[0,mvecs[0],0,mvecs[1]])
	#im = ax.imshow(curvs_map,cmap=mpl.cm.RdBu,vmax=vmax,vmin=-1*vmax,
	#	extent=[0,mvecs[0],0,mvecs[1]])
	#im = ax.imshow(curvs_map,cmap=mpl.cm.RdBu,vmax=vmax,vmin=-1*vmax,origin='lower')
	axins = inset_axes(ax,width="5%",height="100%",loc=3,
		bbox_to_anchor=(1.05,0.,1.,1.),bbox_transform=ax.transAxes,borderpad=0)
	cbar = plt.colorbar(im,cax=axins,orientation="vertical")

	cbar.set_label(r'$\mathrm{C_0\,({nm}^{-1})$',rotation=270)
	ax.set_xlabel('x (nm)')
	ax.set_ylabel('y (nm)')
	ax.tick_params(axis='y',which='both',left='off',right='off',labelleft='on')
	ax.tick_params(axis='x',which='both',top='off',bottom='off',labelbottom='on')
	axins.tick_params(axis='y',which='both',left='off',right='off',labelright='on')
	ax.set_title('curvature map')
	#---only one protein
	ax.scatter(q1o,q2o)
	#ax.axvline(x=10)
	#ax.axhline(y=9.8)
	picturesave('fig.%s.%s'%('curvature',identifier),work.plotdir,backup=False,version=True,meta={})
	plt.close()

def scatterp(l1,l2,l3,p1,p2,p3,identifier):
	#from mpl_toolkits.axes_grid1.inset_locator import inset_axes
	ax = plt.gca()
	ax.set_xlabel('x (nm)')
	ax.set_ylabel('y (nm)')
	ax.tick_params(axis='y',which='both',left='off',right='off',labelleft='on')
	ax.tick_params(axis='x',which='both',top='off',bottom='off',labelbottom='on')
	ax.set_title('curvature map')
	ax.scatter(l1,l2,s=120,c=l3)
	ax.scatter(p1,p2,s=30,c=p3,marker='+')
	#plt.show()
	picturesave('fig.%s-%s'%('scatter',identifier),work.plotdir,backup=False,version=True,meta={})
	plt.close()

def COM(coors,mass):
	if len(coors)>0:
		com = np.average(coors,axis=0,weights=mass)
		com[2] = 0
		return com
	else:
		return np.zeros(3)

def shift(pts,shift):
	return list([p-shift for p in pts])

def repack(pts):
	return (pts-np.floor(pts/vec)*vec)

def wrap(pts,vec,ngrid):
	return (repack(pts)/(vec/ngrid)).astype(int)[:,:2]

#---block: load the calculation data
if 'data' not in globals(): 
	data,calcs = plotload(plotname,work)
	data_prot,calcs_prot = plotload('protein_abstractor',work)

#---block: heat map of curvature from the mesh
if 'curvature' in routine:

	#---settings
	spacing = 0.5
	mn = 0

	sn = 'mk004'
	dat = data[sn]['data']
	nframes = int(dat['nframes'])
	nmol = int(dat['%d.1.nmol'%mn])
	def get(mn,fr,name): return dat['%d.%d.%s'%(mn,fr,name)]

	mvecs = np.mean([get(0,fr,'vec') for fr in range(nframes)],axis=0)
	ngrid = np.round(mvecs/spacing).astype(int)

	#---extract protein coordinates and masses to calculate COM
	prot_coors = data_prot[sn]['data']['points']
	prot_names = data_prot[sn]['data']['names']
	prot_names = [n[0] for n in prot_names]
	prot_mass = [mass_table[i] for i in prot_names]

	#---curvature of each leaflet
	curvs_map = [np.zeros((ngrid[0],ngrid[1])) for mn in range(2)]
	for mn in range(2):
		curvs = np.zeros((ngrid[0],ngrid[1]))
		curvs_counts = np.zeros((ngrid[0],ngrid[1]))
		nmol = int(dat['%d.1.nmol'%mn])
		for fr in range(nframes):
			simps = get(mn,fr,'simplices')
			pts = get(mn,fr,'points')
			vec = get(mn,fr,'vec')
			curv = get(mn,fr,'mean')
			pts_repack = repack(pts)
			prot_pts = repack(prot_coors[fr])
			com = COM(prot_pts,prot_mass)
			pts = shift(pts,com)
			prot_pts = shift(prot_pts,com)
			pts_rounded = wrap(pts,vec,ngrid)
			curvs[pts_rounded[:nmol,0],pts_rounded[:nmol,1]] += curv[:nmol]
			curvs_counts[pts_rounded[:nmol,0],pts_rounded[:nmol,1]] += 1
		obs = np.where(curvs_counts>0)
		means = curvs[obs]/curvs_counts[obs]
		curvs_map[mn][obs] = means

	#---average the leaflets
	curvs_map = np.mean(curvs_map,axis=0)
	#---ironically back to nan for the imshow
	curvs_map[np.where(curvs_counts==0)] = np.nan

	#prot_pts = data_prot[sn]['data']['points_all'].mean(axis=0)[-1] ## average protein coordinates

	q1o = [i[0] for i in prot_pts]
	q2o = [i[1] for i in prot_pts]
	q3o = [i[2] for i in prot_pts]

	#plot(curvs_map,q1o,q2o,mvecs,'unnormalized')
	#scatterp(pts_repack[:,0],pts_repack[:,1],pts_repack[:,2],q1o,q2o,q3o,'shift')

	M,N = curvs_map.shape

	pbcx = M/2
	pbcy = N/2

	block00 = curvs_map[0:pbcx,0:pbcy]
	block10 = curvs_map[0:pbcx,(pbcy+0):]
	block01 = curvs_map[(pbcx+0):,0:pbcy]
	block11 = curvs_map[(pbcx+0):,(pbcy+0):]

	# I want this structure
	# block10 block00
	# block11 block01
	# but imshow is weird so I have to assemble it like this

	new0v_2=np.concatenate((block11,block10),axis=0)
	new1v_2=np.concatenate((block01,block00),axis=0)
	curvs_map=np.concatenate((new0v_2,new1v_2),axis=1)

	#---shift protein to be consistent with reorganization
	q1o = [i[0]+(vec[0]/2) for i in prot_pts]
	q2o = [i[1]+(vec[1]/2) for i in prot_pts]

	plot(curvs_map,q1o,q2o,mvecs,'unfiltered')
	#plot(curvs_map_2,q1s,q2s,mvecs,'re-wrapped')

	#---! these maps are noisy so we smooth them --- no theory here though ...
	import scipy
	import scipy.ndimage
	count=0
	for s in [3,4]:
		curvs_map_f0 = scipy.ndimage.gaussian_filter(curvs_map,sigma=s,order=0,mode='wrap')
		plot(curvs_map_f0,q1o,q2o,mvecs,'gaussian-%d'%(count))
		count+=1

